<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Unpackager</title>
    <style>
      :root {
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      }
      @media (prefers-color-scheme: dark) {
        :root {
          color: #eee;
          background-color: #111;
          color-scheme: dark;
        }
        a {
          color: #4af;
        }
      }

      main {
        max-width: 480px;
        margin: auto;
      }
    </style>
  </head>

  <body>
    <main>
      <h1>Unpackager</h1>

      <p>Select a file generated by the TurboWarp Packager and it'll output the original file that was packaged.</p>
      <p>Note that script positions and comments may be lost as the packager removes these to save space.</p>

      <input type="file" class="file-input" accept=".zip, .html" autocomplete="off">

      <p class="download-section"></p>
    </main>

    <script src="dependencies/jszip.min.js"></script>
    <script>
      (function() {
        'use strict';

        const fileInput = document.querySelector('.file-input');
        const downloadSection = document.querySelector('.download-section');

        /**
         * @returns {Promise<JSZip>}
         */
        const unzipOrNull = async (binaryData) => {
          try {
            return await JSZip.loadAsync(binaryData);
          } catch (e) {
            return null;
          }
        };

        /**
         * @param {Blob} blob
         * @returns {Promise<string>}
         */
        const readAsText = (blob) => new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = () => reject(new Error('Could not read blob as text'));
          reader.readAsText(blob);
        });

        /**
         * @param {string} string
         * @param {RegExp} regex
         * @param {number} index
         * @returns {string[][]}
         */
        const matchAll = (string, regex, index) => {
          const result = [];
          let match = null;
          while ((match = regex.exec(string)) !== null) {
            result.push(match[index]);
          }
          return result;
        };

        const getContainingFolder = (name) => {
          const parts = name.split('/');
          parts.pop();
          return parts.join('/');
        };

        const identifyProjectJSONType = (data) => {
          if ('targets' in data) {
            return 'sb3';
          } else if ('objName' in data) {
            return 'sb2';
          }
          throw new Error('Can not determine project.json type');
        };

        const base85decode = (str) => {
          // https://github.com/TurboWarp/packager/blob/master/src/packager/base85.js
          const getValue = (code) => {
            if (code === 0x28) code = 0x3c;
            if (code === 0x29) code = 0x3e;
            return code - 0x2a;
          };
          const toMultipleOfFour = (n) => {
            if (n % 4 === 0) {
              return n;
            }
            return n + (4 - n % 4);
          };
          const lengthEndsAt = str.indexOf(',');
          const byteLength = +str
            .substring(0, lengthEndsAt)
            .split('')
            .map(i => String.fromCharCode(i.charCodeAt(0) - 49))
            .join('');
          const resultBuffer = new ArrayBuffer(toMultipleOfFour(byteLength));
          const resultView = new Uint32Array(resultBuffer);
          for (let i = lengthEndsAt + 1, j = 0; i < str.length; i += 5, j++) {
            resultView[j] = (
              getValue(str.charCodeAt(i + 4)) * 85 * 85 * 85 * 85 +
              getValue(str.charCodeAt(i + 3)) * 85 * 85 * 85 +
              getValue(str.charCodeAt(i + 2)) * 85 * 85 +
              getValue(str.charCodeAt(i + 1)) * 85 +
              getValue(str.charCodeAt(i))
            );
          }
          return new Uint8Array(resultBuffer, 0, byteLength);
        };

        /**
         * Find a file in a JSZip using its name regardless of the folder it's in.
         * @param {JSZip} zip
         * @param {string} path
         * @returns {JSZip.File|null}
         */
        const findFileInZip = (zip, path) => zip.file(path) || zip.file(new RegExp(`^([^/]*/)?${path}$`))[0];

        const unpackageBinaryBlob = async (data) => {
          const projectZip = await unzipOrNull(data);

          if (projectZip) {
            // The project is a compressed sb2 or sb3 project.
            const projectJSON = findFileInZip(projectZip, 'project.json');
            const projectJSONData = JSON.parse(await projectJSON.async('text'));
            const type = identifyProjectJSONType(projectJSONData);
            return {
              type,
              data
            };
          }

          // The project is a Scratch 1 project.
          return {
            type: 'sb',
            data
          };
        };

        const unpackage = async (blob) => {
          const packagedZip = await unzipOrNull(blob);

          if (packagedZip) {
            const projectJSON = findFileInZip(packagedZip, 'project.json');
            if (projectJSON) {
              // The project is an uncompressed sb3 project.
              const innerFolderPath = getContainingFolder(projectJSON.name);
              const innerZip = packagedZip.folder(innerFolderPath);
  
              return {
                type: 'sb3',
                data: await innerZip.generateAsync({
                  type: 'arraybuffer',
                  compression: 'DEFLATE'
                })
              };
            }

            const projectBinary = findFileInZip(packagedZip, 'project.zip');
            if (projectBinary) {
              const projectData = await projectBinary.async('arraybuffer');
              return unpackageBinaryBlob(projectData);
            }

            throw new Error('Input was a zip but we could not find a project.')
          }

          const text = await readAsText(blob);
          const base85Segments = matchAll(text, /<script type="p4-project">([^<]+)<\/script>/g, 1);
          if (base85Segments.length) {
            const decoded = base85decode(base85Segments.join(''));
            return unpackageBinaryBlob(decoded);
          }
        };

        fileInput.addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (!file) {
            return;
          }

          while (downloadSection.firstChild) {
            downloadSection.firstChild.remove();
          }

          try {
            const unpackaged = await unpackage(file);
            const type = unpackaged.type;
            const data = unpackaged.data;
            const name = `${file.name}.${type}`;

            const blob = new Blob([data], {
              type: `application/x.scratch.${type}`
            });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.href = url;
            link.download = name;
            link.textContent = `Download ${name} (${(blob.size / 1000 / 1000).toFixed(2)}MB)`;
            downloadSection.appendChild(link);
            link.click();
          } catch (e) {
            console.error(e);
            alert(e);
          }
        });
      }());
    </script>
  </body>
</html>
