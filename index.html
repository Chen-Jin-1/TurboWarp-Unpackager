<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Unpackager</title>
    <style>
      :root {
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      }
      @media (prefers-color-scheme: dark) {
        :root {
          color: #eee;
          background-color: #111;
          color-scheme: dark;
        }
        a {
          color: #4af;
        }
      }

      main {
        max-width: 480px;
        margin: auto;
      }

      .warning {
        padding: 8px;
        background: yellow;
        color: black;
        border-radius: 8px;
      }
    </style>
  </head>

  <body>
    <main>
      <h1>Unpackager</h1>

      <p>Select an HTML or zip file generated by the TurboWarp Packager, the forkphorus packager, or HTMLifier and this tool will try to extract the original Scratch project.</p>

      <p class="warning">The unpackager is in a very early state of development. Expect to find bugs. We don't know if this will be maintained long term.</p>

      <input type="file" class="file-input" accept=".zip, .html" autocomplete="off">

      <p class="download-section"></p>

      <p>
        <a href="https://github.com/TurboWarp/unpackager/issues">Report bugs</a>
      </p>

      <p>
        <a href="https://github.com/TurboWarp/unpackager">Source code</a>
      </p>
    </main>

    <script src="dependencies/jszip.min.js"></script>
    <script>
      (function() {
        'use strict';

        const fileInput = document.querySelector('.file-input');
        const downloadSection = document.querySelector('.download-section');

        /**
         * @returns {Promise<JSZip>}
         */
        const unzipOrNull = async (binaryData) => {
          try {
            return await JSZip.loadAsync(binaryData);
          } catch (e) {
            return null;
          }
        };

        /**
         * @param {Blob} blob
         * @returns {Promise<string>}
         */
        const readAsText = (blob) => new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = () => reject(new Error('Could not read blob as text'));
          reader.readAsText(blob);
        });

        /**
         * @param {string} string
         * @param {RegExp} regex
         * @returns {string[][]}
         */
        const matchAll = (string, regex) => {
          const result = [];
          let match = null;
          while ((match = regex.exec(string)) !== null) {
            result.push(match);
          }
          return result;
        };

        const getContainingFolder = (name) => {
          const parts = name.split('/');
          parts.pop();
          return parts.join('/');
        };

        const identifyProjectJSONType = (data) => {
          if ('targets' in data) {
            return 'sb3';
          } else if ('objName' in data) {
            return 'sb2';
          }
          throw new Error('Can not determine project.json type');
        };

        const decodeBase85 = (str) => {
          // https://github.com/TurboWarp/packager/blob/master/src/packager/base85.js
          const getValue = (code) => {
            if (code === 0x28) code = 0x3c;
            if (code === 0x29) code = 0x3e;
            return code - 0x2a;
          };
          const toMultipleOfFour = (n) => {
            if (n % 4 === 0) {
              return n;
            }
            return n + (4 - n % 4);
          };
          const lengthEndsAt = str.indexOf(',');
          const byteLength = +str
            .substring(0, lengthEndsAt)
            .split('')
            .map(i => String.fromCharCode(i.charCodeAt(0) - 49))
            .join('');
          const resultBuffer = new ArrayBuffer(toMultipleOfFour(byteLength));
          const resultView = new Uint32Array(resultBuffer);
          for (let i = lengthEndsAt + 1, j = 0; i < str.length; i += 5, j++) {
            resultView[j] = (
              getValue(str.charCodeAt(i + 4)) * 85 * 85 * 85 * 85 +
              getValue(str.charCodeAt(i + 3)) * 85 * 85 * 85 +
              getValue(str.charCodeAt(i + 2)) * 85 * 85 +
              getValue(str.charCodeAt(i + 1)) * 85 +
              getValue(str.charCodeAt(i))
            );
          }
          return new Uint8Array(resultBuffer, 0, byteLength);
        };

        /**
         * @param {string} str
         * @returns {Uint8Array}
         */
        const decodeBase64 = (str) => {
          const decoded = atob(str);
          const result = new Uint8Array(decoded.length);
          for (let i = 0; i < decoded.length; i++) {
            result[i] = decoded.charCodeAt(i);
          }
          return result;
        };

        /**
         * @param {string} uri
         */
        const decodeDataURI = (uri) => {
          const parts = uri.split(';base64,');
          if (parts.length < 2) {
            throw new Error('Data URI is not base64');
          }
          const base64 = parts[1];
          return decodeBase64(base64);
        };

        /**
         * Find a file in a JSZip using its name regardless of the folder it's in.
         * @param {JSZip} zip
         * @param {string} path
         * @returns {JSZip.File|null}
         */
        const findFileInZip = (zip, path) => {
          const f = zip.file(path);
          if (f) {
            return f;
          }
          for (const filename of Object.keys(zip.files)) {
            if (filename.endsWith(`/${path}`)) {
              return zip.file(filename);
            }
          }
          return null;
        };

        const unpackageBinaryBlob = async (data) => {
          const projectZip = await unzipOrNull(data);

          if (projectZip) {
            // The project is a compressed sb2 or sb3 project.
            const projectJSON = findFileInZip(projectZip, 'project.json');
            const projectJSONData = JSON.parse(await projectJSON.async('text'));
            const type = identifyProjectJSONType(projectJSONData);
            return {
              type,
              data
            };
          }

          // The project is a Scratch 1 project.
          return {
            type: 'sb',
            data
          };
        };

        const unpackage = async (blob) => {
          const packagedZip = await unzipOrNull(blob);

          if (packagedZip) {
            // Zip files generated by the TurboWarp Packager can have a project.json alongside the assets
            const projectJSON = findFileInZip(packagedZip, 'project.json');
            if (projectJSON) {
              // The project is an sb3 project.
              const innerFolderPath = getContainingFolder(projectJSON.name);
              const innerZip = packagedZip.folder(innerFolderPath);

              // TODO: delete extra files that aren't part of the project such as in an HTMLifier zip
  
              return {
                type: 'sb3',
                data: await innerZip.generateAsync({
                  type: 'arraybuffer',
                  compression: 'DEFLATE'
                })
              };
            }

            const projectBinary = (
              // Zip files generated by the TurboWarp Packager, the legacy TurboWarp Packager, or the forkphorus packager
              // can have a "project.zip" file
              findFileInZip(packagedZip, 'project.zip') ||
              // Zip files generated by HTMLifier for Scratch 1 projects have a "project" file
              findFileInZip(packagedZip, 'project')
            );
            if (projectBinary) {
              const projectData = await projectBinary.async('arraybuffer');
              return unpackageBinaryBlob(projectData);
            }

            throw new Error('Input was a zip but we could not find a project.')
          }

          const text = await readAsText(blob);

          // HTML files generated by the TurboWarp Packager use base85 in inline script tags
          const base85Matches = matchAll(text, /<script type="p4-project">([^<]+)<\/script>/g);
          if (base85Matches.length) {
            const base85 = base85Matches.map(i => i[1]).join('');
            return unpackageBinaryBlob(decodeBase85(base85));
          }

          const dataURIMatch = (
            // HTML files generated by the forkphorus packager use an inline base64 URL
            text.match(/var project = '([a-zA-Z0-9+/=\-:;,]+)';/) ||
            // HTML files generated by the legacy TurboWarp Packager use an inline base64 URL
            text.match(/window\.__PACKAGER__ = {\n    projectData: "([a-zA-Z0-9+/=\-:;,]+)"/)
          );
          if (dataURIMatch) {
            const dataURI = dataURIMatch[1];
            return unpackageBinaryBlob(decodeDataURI(dataURI));
          }

          // HTML files generated by HTMLifier have an inline JSON options object with inline base64
          const htmlifierOptions = text.match(/<script>\nconst GENERATED = \d+\nconst initOptions = ({[\s\S]+})\ninit\(initOptions\)\n<\/script>/m);
          if (htmlifierOptions) {
            const htmlifierAssets = JSON.parse(htmlifierOptions[1]).assets;

            const compressedProjectData = htmlifierAssets.file;
            if (compressedProjectData) {
              // The project is a Scratch 1 project
              const decodedProjectData = decodeDataURI(compressedProjectData);
              return {
                type: 'sb',
                data: decodedProjectData
              };
            }

            // The project is a Scratch 3 project with assets listed individually in the JSON options
            // or the project was a Scratch 2 project which HTMLifier converts to Scratch 3
            const newZip = new JSZip();
            for (const name of Object.keys(htmlifierAssets)) {
              const nameInZip = name === 'project' ? 'project.json' : name;
              const dataURI = htmlifierAssets[name];
              newZip.file(nameInZip, decodeDataURI(dataURI));
            }

            return {
              type: 'sb3',
              data: await newZip.generateAsync({
                type: 'arraybuffer',
                compression: 'DEFLATE'
              })
            };
          }

          throw new Error('Input was not a zip and we could not find project.');
        };

        fileInput.addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (!file) {
            return;
          }

          while (downloadSection.firstChild) {
            URL.revokeObjectURL(downloadSection.firstChild.href);
            downloadSection.firstChild.remove();
          }

          try {
            const unpackaged = await unpackage(file);
            const type = unpackaged.type;
            const data = unpackaged.data;
            const name = `${file.name}.${type}`;

            const blob = new Blob([data], {
              type: `application/x.scratch.${type}`
            });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.href = url;
            link.download = name;
            link.textContent = `Download ${name} (${(blob.size / 1000 / 1000).toFixed(2)}MB)`;
            downloadSection.appendChild(link);
            link.click();
          } catch (e) {
            console.error(e);
            alert(e);
          }
        });
      }());
    </script>
  </body>
</html>
